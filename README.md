# Язык
## Краткий обзор
### О самом языке
Устроен по принципу `EBNF` (как требовало задание). А также:
+ А-ля ***C++*** читает всё "сверху вниз". Если мы хотим что-то использовать, это должно было быть определено заранее
  + Причина так делать проста: `A := C`, а затем `C := A` выглядит жутко и бесконечно развертывается, эти моменты легко ловить `dfs` поиск цикла , но ИМХО лучше сразу не допускать
+ Каждая строка может быть устроена 2 способами
  + A := B -- идентификатору A присваиваем B
  + return A -- то, что мы хотим вернуть
+ Есть однострочные и многострочные комментарии
+ Каждое новое правило -- новая строка
### Немного о сборке
+ `compile.sh` скомпилирует всё, что нужно
+ Есть `run.sh` -- она выдаст ошибки в консоль (в 2>>), если они есть. Release-версия своего рода
+ `run-debug.sh` -- более подробно опишет в консоли весь процесс, который происходил с кодом. Рекомендую :)

P.S. делал только под Linux. В остальных ОС красивая подсветка не сработает в консоли:) 
```bash
./run-debug.sh input
```
+ Код с удаленными комментариями выдаст в `input.out`
+ ***Дерево в виде кода, который можно вставить в [Рисовальщик графа](https://edotor.net/), выдаст в `input.out.out`***
## Литералы, идентификаторы, ключевые
### Литералы
Литералом является любая последовательность внутри `^.^` -- это как кавычки. Если нужна внутри кавычка -- `\^`

### Ключевые слова
+ return -- используется для вывода работы программы
### Идентификаторы
+ пусть будет `[a-z].[A-Za-z0-9_]*` -- то есть для приличия начинаем с маленькой буквы:)
## Операторы
Не будем изобретать велосипед по поводу символов. Запишем в порядке убывания приоритета.
+ `()` -- Скобки для группировки (круглые)
+ `*` -- Повторение (0 или больше повторений аргумента)
  + Применение: `A*` или `*A`
+ `?` -- Опциональный оператор (0 или 1 вхождение аргумента)
  + Применение: `A?` или `?A`
+ `+` -- Конкатенация (2 аргумента)
  + Применение: `A + B` (некоммутативна очевидно, `A` и `B` склеятся в `AB`)
+ `|` -- Альтернатива (2 аргумента)
  + Применение `A | B` (коммутативная)
## Пробелы
Без разницы. Кроме случая с `return A`. Тут нужен хотя бы один между `return` и `A`. 
## Препроцессинг
Препроцессинг состоит из трёх этапов: 
+ удаление комментариев (на данном этапе никаких ошибок возникнуть не может)
+ разбираемся с ```#define```  (?) ( Этого нет, на будущее:) )

Код препроцессора в `preprocessor.cpp`. Работает примерно так: идём по символам кода:
+ Если мы внутри литерала -- ждём когда он закончится
+ Далее заменяем комментарий на пустую строку, чтобы сохранит нумерацию строк стандартную
### Комментарии
***Важно***: здесь и далее считаем, что комментарий, встреченный внутри литерала типа `String` -- не комментарий (как, например в 
C++, если написать `^abc//0dkdk^` или `^ad/*fdfg */^`, то за комментарий не засчитается)
#### Однострочные
Однострочные комментарии воспринимаются следующим образом:
+ <код> `@` <комментарий до перевода строки `\n`>

То есть от символа `@` до `\n`.
#### Многострочные
Многострочные комментарии начинаются `@*` и заканчивается первым вхождением `*@`
(Да, если внутри встречается `@` (однострочный) -- всё равно). Также справедливо:
+ Если открылся `@*`, но не закрылся `*@` до конца файла, считаем, что закрылся в конце (то есть признаем комментарием с начала `@*`)
## Ошибки
+ переменная не была ранее объявлена
  + *Parse error line N:M: Variable A is used, but has not been previously declared*
+ правило не устроено по типу `A := B` или `return A`
  + *Syntax error: where is := ? or return ?*
+ неопознанный символ
  + *Parse error: The symbol x on line N сannot be used.*
+ Ну и много других мелких и частных. В примерах в (tests) есть. Иногда что-то подсвечивается (например, некорректный символ)