# Язык
## Краткий обзор
### О самом языке
Устроен по принципу `EBNF` (как требовало задание). А также:
+ А-ля ***C++*** читает всё "сверху вниз". Если мы хотим что-то использовать, это должно было быть определено заранее
  + Причина так делать проста: `A := C`, а затем `C := A` выглядит жутко и бесконечно развертывается, эти моменты легко ловить `dfs` поиск цикла , но ИМХО лучше сразу не допускать
+ Каждая строка может быть устроена 2 способами
  + A := B -- идентификатору A присваиваем B
  + return A -- то, что мы хотим вернуть
+ Есть однострочные и многострочные комментарии
+ Каждое новое правило -- новая строка
### Немного о сборке
+ Есть run.sh -- она выдаст ошибки в консоль (в 2>>), если они есть. Release-версия своего рода
+ run-debug.sh -- более подробно опишет в консоли весь процесс, который происходил с кодом. Рекомендую :)

P.S. делал только под Linux. В остальных ОС красивая подсветка не сработает в консоли:) 
```bash
./run-debug.sh "example.ok"
```
Дерево выдаст в `example.ok.out`
+ `./clear.sh` почистит все `out.png`
## Литералы, идентификаторы, ключевые
### Литералы
Зададим регулярными
+ Целое число `[-]?[0-9]+` (да, ведущие нули можно)
+ Double `[-]?[0-9]+\.[0-9]+` (то есть возможен минус, потом ненулевое кол-во цифр, точка и опять неулевое кол-во цифр)
+ String `".*"` (что угодно внутри двойных кавычек). ***Также***: если внутри литерала хотим двойную, то пишем `\"`
### Ключевые слова
+ return -- используется для вывода работы программы
### Идентификаторы
+ пусть будет `[A-Za-z_].[A-Za-z0-9_]*` -- то есть для приличия с цифры не начинаем:)
## Операторы
Не будем изобретать велосипед по поводу символов. Запишем в порядке убывания приоритета.
+ `()` -- Скобки для группировки (круглые)
+ `*` -- Повторение (0 или больше повторений аргумента)
  + Применение: `A*`
+ `?` -- Опциональный оператор (0 или 1 вхождение аргумента)
  + Применение: `A?`
+ `+` -- Конкатенация (2 аргумента)
  + Применение: `A + B` (некоммутативна очевидно, `A` и `B` склеятся в `AB`)
+ `|` -- Альтернатива (2 аргумента)
  + Применение `A | B` (коммутативная)
## Пробелы
Без разницы. Кроме случая с `return A`. Тут нужен. Все остальные пробелы удалятся при препроцессинге вместе с табуляциями.
## Препроцессинг
Препроцессинг состоит из трёх этапов: 
+ удаление комментариев (на данном этапе никаких ошибок возникнуть не может)
+ удаление повторяющихся переводов строки (здесь тоже)
+ удаление табуляций и пробелов(ну и здесь)
+ разбираемся с ```#define```  (?)

Код препроцессора в `preprocessor.cpp`
### Комментарии
***Важно***: здесь и далее считаем, что комментарий, встреченный внутри литерала типа `String` -- не комментарий (как, например в 
C++, если написать "abc//0dkdk" или "ad/*fdfg */", то за комментарий не засчитается)
#### Однострочные
Однострочные комментарии воспринимаются следующим образом:
+ <код> `@` <комментарий до перевода строки `\n`>

То есть от символа `@` до `\n`.
#### Многострочные
Многострочные комментарии начинаются `@*` и заканчивается первым вхождением `*@`
(Да, если внутри встречается `@` -- всё равно). Также справедливо:
+ Если открылся `@*`, но не закрылся `*@` до конца файла, считаем, что закрылся в конце (то есть признаем комментарием с начала `@*`)
## Ошибки
+ нет `return`
  + *Parse error: Your program returns nothing. "Return" was expected on one of the lines*
+ переменная не была ранее объявлена
  + *Parse error: Variable A is used on line \<N>, but has not been previously declared*
+ правило не устроено по типу `A = B` или `return A`
  + *Syntax error: The rule must follow a pattern (A = B) or (return A), but not ...*
+ неопознанный символ
  + *Parse error: The symbol x on line N сannot be used
+ правильная скобочная последовательность