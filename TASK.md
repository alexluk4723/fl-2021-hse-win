# Проекты

Проекты индивидуальные, но типовые (для тех, кто не высказал явных пожеланий). Если не сказано иное, проект заключается в разработке конкретного синтаксиса языка по заданному абстрактному синтаксису (подробности в [ConcreteSyntax.md](tasks/ConcreteSyntax.md)), реализации для него синтаксического анализатора (подробности в [Parser.md](tasks/Parser.md)) и поддержки в среде разработки ((подробности в [IdeSupport.md](tasks/IdeSupport.md))).

Типовой проект на одного человека подразумевает реализацию или парсера, или поддержку в среде разработки. В случае выбора поддержки в среде разработки, должна быть реализована какая-нибудь нетривиальная фича (что-нибудь сложнее подсветки лексики).

Если в задании написано "присоединиться к" кому-то, то типовой проект на одного превращается в типовой проект.

Если не сказано иное, задачи внутри проекта распределяете сами. Каждый участник должен выполнить нетривиальную часть проекта.

По результату проекта должен быть предоставлен отчет, в котором описано:

* В чем состояла задача
* Как вы ее решали. Например, какой и почему выбрали синтаксис, как парсили, как поддерживали в среде разработки.
* Какие сложности возникли и как их преодолели.
* Что конкретно сделал каждый человек из группы.

## Темы проектов, группа Вербицкой

* Бобров + Суворов

   * Типовой проект, язык [EBNF](lang/EBNF.md) без особенностей синтаксиса.

* Михайлова

   * Типовой проект на одного, язык [M](lang/M.md) без особенностей синтаксиса.

* Полушин

   * Типовой проект на одного, язык [L](lang/L.md) без особенностей синтаксиса.

* Сапожников + Лехман

   * Типовой проект, язык [L](lang/L.md) + особенность синтаксиса 4.

* Бондаренко

   * Типовой проект на одного, язык [EBNF](lang/EBNF.md) + особенность синтаксиса 1.

* Буянтуев + Игнатов + Федотова

   * Сравнить 3 разных генератора парсеров (например, yacc, antlr, bison) на нетривиальном языке (пусть он будет существенно неоднозначным). Сравнивать производительность, сложность реализации самих парсеров, и что тул делает, чтобы неоднозначности порешать. У bison есть режим GLR, он должен работать с любой КС грамматикой, выдавая все возможные варианты разбора

* Василевский + Полупанова

   * Написать парсер "на коленке" рекурсивным спуском, который будет выдавать сравнимую производительность с yacc для конкретного синтаксиса, разработанного для языка [L](lang/L.md).

* Громов

   * Сравнить bison и yacc по следующим параметрам.
      * Классы грамматик, которые они поддерживают: какие грамматики переваривает один инструмент, но не переваривает другой.
      * Как работают с нетривиальными особенностями синтаксиса (см. [Extensions.md](exts/Extensions.md))
      * Как обстоят дела с часто повторяющимися паттернами типа арифметики, списков с разделителями, комментариев...
   * Подготовить отчет. Отчет должен содержать примеры грамматик, ссылки на доки и в целом быть читаемым.

* Мартюшев (проект с Поздняковым)
   * Поздняков пишет фронтенд (парсит дка из файла, поддерживает язык в среде разработки),
   * Мартюшев переводит автомат в регулярку.
   * Перевод должен работать пошагово, то есть промежуточные шаги должны как-то отображаться.

* Плотников
   * Типовой проект на одного, язык [M](lang/M.md) + особенность синтаксиса 2.

* Савина
   * Поисследовать, как нынче парсится c++.
   * Какие в синтаксисе есть особенности, помимо стандартного lexer hack.
   * Кто-то когда-то говорил, что gcc проводит чуть ли не 40% времени за синтаксическим анализом -- проверить это утверждение.
   * Может ли парсер выдать отвратительную производительность? Привести пример, если удастся.
   * Тут основным результатом будет хорошо написанный отчет с примерами.

* Дымашевский + Трофимова
   * Типовой проект, язык [EBNF](lang/EBNF.md) + особенности синтаксиса 1 и 2. 

* Горелова + Браун
   * Графическое отображение путей в графе.
   * Читаем описание автомата из файла (можно использовать свой язык описаний, можно посмотреть, что там готовые библиотеки для работы с графами умеют), читаем входную строку, рисуем строку на автомате.

* Креславский
   * Парсер собственного описания автоматов (оно достаточно объемное). 

* Кукса
   * Типовой проект для языка [M](lang/M.md) на парсер-комбинаторах.

* Денисов
   * Типовой проект для языка [L](lang/L.md) + особенность синтаксиса 3.

* Курагин
   * Присоединиться к Плотникову, добавляем особенность синтаксиса 1.

* Лукьянов 
   * Типовой проект на одного, язык [EBNF](lang/EBNF.md). 
 

## Темы проектов, группа Трилиса

* Константинов

   * Реализовать парсер для языка с заданным конкретным синтаксисом ([P.md](lang/P.md)).
   * Использовать другой инструмент для написания парсеров, нежели Чайка.

* Чайка

   * Реализовать парсер для языка с заданным конкретным синтаксисом ([P.md](lang/P.md)).
   * Использовать другой инструмент для написания парсеров, нежели Константинов.

* Кудашева

   * Типовой проект на одного, язык [EBNF](lang/L.md) без особенностей синтаксиса.

* Асылханова + Джекшембаев

   * Конкретный синтаксис + парсер + интервальный анализ для языка [L](lang/L.md).
   * Можно ограничиться внутрипроцедурным анализом, иначе может быть слишком много работы.

* Захаренко + Морозов + Шереметов

   * Парсер-комбинаторы! (Это такой способ писать рекурсивный спуск на языках с функциями высшего порядка).
   * Реализовать парсер языка [L](lang/L.md), используя три разных комбинаторных библиотеки. Рекомендую использовать Haskell, но можете себя не ограничивать одним языком. Говорят, даже на питоне есть комбинаторные библиотеки.
   * Сравнить по скорости, сложности реализации, качеству сообщений об ошибках.

* Корнаухов + Степанов + Журавлев

   * Конкретный синтаксис, парсер, поддержка в среде разработки и компиляция подмножества языка [L](lang/L.md) без функций.
   * Можно попробовать реализовать при помощи голых атрибутных грамматик, без явного построения дерева разбора. Если не получится -- ничего страшного.

* Кудрявцев
   * Типовой проект на одного, язык [EBNF](lang/EBNF.md) + особенность синтаксиса 2.

* Малофеев + Петроченков + Всемирнов
   * Типовой проект, язык [L](lang/L.md), особенности синтаксиса 1, 3, 4.

* Поздняков (проект с Мартюшевым)

   * Мартюшев пишет пошаговое преобразование ДКА к регулярке.
   * Поздняков реализует фронтенд:
      * Парсинг автомата из файла
      * Поддержка на стороне среды разработки.
      * Язык для описания автоматов должен быть человекочитаемым.
      * В поддержке в среде разработки сделать форматтер кода (например, чтобы группировал переходы, удалял повторяющиеся…)

* Сороковикова + Ву + Наумцев
   * Парсинг веб-старниц.
   * Обязательно добавить исследовательскую компоненту: понять, какие особенности сложны с точки зрения парсинга, где может не хватать возможностей библиотеки
   * Сначала составить план с конкретными задачами и утвердить его с проверяющими.

* Туров + Храмов

   * Типовой проект, язык [M](lang/M.md) с особенностью синтаксиса 4.

* Шереметев

   * Типовой проект на одного, язык [EBNF](lang/EBNF.md) с особенностью синтаксиса 1.

* Шестаков + Зеленцова

   * Типовой проект, язык [L](lang/L.md). Тут упор на поддержку в среде разработки. Подумать, какие нетривиальные фичи среды разработки можно поддержать, чем нетривиальнее, тем лучше. Может быть иметь смысл усложнить абстрактный синтаксис языка.

* Воробьев (один из двух вариантов)

   * Присоединиться к Шереметьеву, добавляем 2 особенность синтаксиса
   * Реализовать на Haskell подход с синтаксическим анализом через производные для КС языков (написать @kajigor, если выберете этот вариант, чтобы получить ссылки на статьи)

* Зорабов

   * Присоединиться к Кудрявцеву, добавляем к языку 1 особенность синтаксиса

* Шабес + Лопатин

   * Типовой проект, язык [M](lang/M.pdf) + особенность синтаксиса 3.

